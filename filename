// 中央角色與下方多狀態精靈動畫範例
// 中央：使用 '角色/全部.png'（原有）
// 下方：顯示 idle/walk/run/attack 四種狀態，按鍵控制

let spriteImg; // 中央的舊精靈（如果有）
let bgImg; // 背景圖片
const SRC_W = 61; // 若有，保留原來的 source 設定
const SRC_H = 78;
let FRAMES = 0;
const DISPLAY_W = 56;
const DISPLAY_H = 78;
let frameIndex = 0;
let lastFrameTime = 0;
const FRAME_DURATION = 60;

// 下方多狀態精靈
let idleImg, walkImg, runImg, attackImg;
const anims = {
  idle: { img: null, frames: 2, srcW: 0, srcH: 0, dispW: 0, dispH: 0 },
  walk: { img: null, frames: 4, srcW: 0, srcH: 0, dispW: 0, dispH: 0 },
  run:  { img: null, frames: 4, srcW: 0, srcH: 0, dispW: 0, dispH: 0 },
  attack: { img: null, frames: 3, srcW: 0, srcH: 0, dispW: 0, dispH: 0 }
};

let currentAnimKey = 'idle';
let prevAnimKey = 'idle';
let isAttack = false;
let bottomFrameIndex = 0;
let bottomLastFrameTime = 0;
const BOTTOM_FRAME_DURATION = 100; // 可調整播放速度

// 下方角色位置與方向
let bottomX = 0; // 初始位置（會在 setup 中設定為 width / 2）
let bottomY = 0;
let direction = 1; // 1 = 右, -1 = 左
const MOVE_SPEED = 3; // 走路速度（像素/幀，可調整）
const RUN_SPEED = 6;  // 跑步速度（像素/幀，可調整）

// 問題1 精靈（單張圖片，固定尺寸）
let problem1Img = null;
const PROBLEM1_W = 40;
const PROBLEM1_H = 91;

// 問題1答對精靈（3張圖片，298x52）
let problem1CorrectImg = null;
const PROBLEM1_CORRECT_W = 298;
const PROBLEM1_CORRECT_H = 52;
let problem1CorrectFrameIndex = 0;
let problem1CorrectLastFrameTime = 0;
const PROBLEM1_CORRECT_FRAME_DURATION = 150;
let isProblem1Answered = false; // 記錄問題1是否已答對
let problem1DeathFinished = false; // 死亡動畫是否已播放完畢（播放一次）
let problem1DeathDirection = 1; // 記錄問題1死亡時的方向

// --- 問題2: 右側精靈（不動：3張 217x49；死亡動畫：8張 875x49）
let problem2Img = null;
const PROBLEM2_W = 217;
const PROBLEM2_H = 49;
let problem2FrameIndex = 0;
let problem2LastFrameTime = 0;
const PROBLEM2_FRAME_DURATION = 200; // 游標動畫速度

let problem2DeathImg = null;
const PROBLEM2_DEATH_W = 875;
const PROBLEM2_DEATH_H = 49;
let problem2DeathFrameIndex = 0;
let problem2DeathLastFrameTime = 0;
const PROBLEM2_DEATH_FRAME_DURATION = 120;
let isProblem2Answered = false; // 問題2答對狀態
let problem2DeathFinished = false; // 死亡動畫是否已播放完畢（播放一次）
let problem2DeathDirection = 1; // 記錄問題2死亡時的方向

// 題目系統
const QUESTIONS = [
  { text: "地錯貝爾的母親叫甚麼名字?", answer: "梅特利亞", hint: "梅00亞" },
  { text: "地錯貝爾的魔法叫做麼?", answer: "火焰閃電", hint: "火0閃0" }
];
let currentQuestion = null;
let userInput = "";
let questionActive = false;
let questionStartTime = 0;

// 碰撞檢測相關
// 碰撞檢測相關（分別為問題1與問題2獨立檢查）
let lastCollisionCheckP1 = 0;
let lastCollisionCheckP2 = 0;
const COLLISION_CHECK_INTERVAL = 100; // 每100ms檢查一次
const COLLISION_DISTANCE_P1 = 80; // 問題1 碰撞偵測範圍
const COLLISION_DISTANCE_P2 = 100; // 問題2 碰撞偵測範圍（較大，方便觸發）

// 固定 X 或偏移量（便於微調位置）
const PROBLEM1_X = 100; // 問題1 固定 X
const PROBLEM2_X_OFFSET = 100; // 問題2 距離右側的偏移量（小）

function preload() {
  // 載入背景圖片
  bgImg = loadImage('origbig.png');
 
  // 中央精靈（如果你的專案需要保留）
  spriteImg = loadImage('角色/全部.png');

  // 下方四種狀態的精靈表
  idleImg = loadImage('角色/全部停止.png');      // 2 幀, 總尺寸 147 x 85
  walkImg = loadImage('角色/全部跑步.png');      // 4 幀, 總尺寸 247 x 91
  runImg  = loadImage('角色/全部跑步.png');      // 4 幀, 總尺寸 391 x 81
  attackImg = loadImage('角色/全部攻擊.png');   // 3 幀, 總尺寸 400 x 77
  
  // 載入問題1單張精靈
  problem1Img = loadImage('角色/問題1不動.png');
  
  // 載入問題1答對動畫精靈（3張圖片）
  problem1CorrectImg = loadImage('角色/問題1答對.png');
  
  // 載入問題2精靈（3 幀, 總寬 217, 高 49）與死亡動畫（8 幀, 總寬 875, 高 49）
  problem2Img = loadImage('角色/問題二不動.png');
  problem2DeathImg = loadImage('角色/問題二死亡.png');
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  imageMode(CENTER);

  // 中央精靈的幀數（若沒有載入成功這行不會造成錯誤）
  if (spriteImg) {
    FRAMES = Math.max(1, Math.floor(spriteImg.width / SRC_W));
  }
  lastFrameTime = millis();

  // 設定下方各精靈屬性（依載入後的圖檔計算每格寬度）
  anims.idle.img = idleImg;
  anims.walk.img = walkImg;
  anims.run.img = runImg;
  anims.attack.img = attackImg;

  // 想要下方動畫顯示的高度（像素），可調整此值
  const bottomDisplayH = 78; // 例如 78px 高

  for (let k in anims) {
    const a = anims[k];
    if (a.img) {
      a.srcW = Math.max(1, a.img.width / a.frames);
      a.srcH = a.img.height;
      // 保持高度為 bottomDisplayH，計算寬度以保持比例
      const scale = bottomDisplayH / a.srcH;
      a.dispH = a.srcH * scale;
      a.dispW = a.srcW * scale;
    }
  }
  bottomLastFrameTime = millis();
  
  // 初始化下方角色位置
  bottomX = width / 2;
  bottomY = height - 40; // 離底部約 40px
  
  lastCollisionCheckP1 = millis();
  lastCollisionCheckP2 = millis();
  
  // 設置中文輸入支持
  setupChineseInput();
}

// 設置中文輸入法支持
function setupChineseInput() {
  const hiddenInput = document.getElementById('hiddenInput');
  if (hiddenInput) {
    // 監聽輸入事件（適用於中文、英文、特殊字符等）
    hiddenInput.addEventListener('input', (e) => {
      if (questionActive) {
        userInput = e.target.value;
      }
    });
    
    // 監聽鍵盤按下事件
    hiddenInput.addEventListener('keydown', (e) => {
      if (questionActive) {
        if (e.key === 'Enter') {
          e.preventDefault();
          if (currentQuestion) {
            checkAnswer();
          }
        } else if (e.key === 'Backspace') {
          e.preventDefault();
          userInput = userInput.slice(0, -1);
          hiddenInput.value = userInput;
        }
      }
    });
  }
}

function draw() {
  // 1. 先填滿底色，清除上一幀的畫面 (解決殘影問題)
  background(220);

  // 2. 繪製背景圖片，並強制拉伸至全視窗大小
  if (bgImg) {
    push();
    imageMode(CORNER); // 暫時切換為左上角定位，方便拉伸
    image(bgImg, 0, 0, width, height);
    pop();
  }
  
  // --- 中央原本的動畫（保持不變） ---
  if (spriteImg && FRAMES > 0) {
    if (millis() - lastFrameTime > FRAME_DURATION) {
      frameIndex = (frameIndex + 1) % FRAMES;
      lastFrameTime = millis();
    }
    const sx = frameIndex * SRC_W;
    const sy = 0;
    noTint();
    image(spriteImg, width / 2, height / 2, DISPLAY_W, DISPLAY_H, sx, sy, SRC_W, SRC_H);
  }

  // --- 下方狀態機與移動控制 ---
  if (!isAttack) {
    let currentSpeed = MOVE_SPEED; // 預設為走路速度
    
    // 按住 d 向右走；若同時按住 shift，改為跑步
    if (keyIsDown(68)) { // 'd'
      if (direction !== 1) {
        direction = 1; // 面向右
        bottomFrameIndex = 0;
      }
      if (keyIsDown(16)) { // shift
        if (currentAnimKey !== 'run') { currentAnimKey = 'run'; bottomFrameIndex = 0; }
        currentSpeed = RUN_SPEED; // 跑步速度
      } else {
        if (currentAnimKey !== 'walk') { currentAnimKey = 'walk'; bottomFrameIndex = 0; }
        currentSpeed = MOVE_SPEED; // 走路速度
      }
      // 向右移動
      bottomX += currentSpeed;
    } 
    // 按住 a 向左走；若同時按住 shift，改為跑步
    else if (keyIsDown(65)) { // 'a'
      if (direction !== -1) {
        direction = -1; // 面向左
        bottomFrameIndex = 0;
      }
      if (keyIsDown(16)) { // shift
        if (currentAnimKey !== 'run') { currentAnimKey = 'run'; bottomFrameIndex = 0; }
        currentSpeed = RUN_SPEED; // 跑步速度
      } else {
        if (currentAnimKey !== 'walk') { currentAnimKey = 'walk'; bottomFrameIndex = 0; }
        currentSpeed = MOVE_SPEED; // 走路速度
      }
      // 向左移動
      bottomX -= currentSpeed;
    } 
    else {
      if (currentAnimKey !== 'idle') { currentAnimKey = 'idle'; bottomFrameIndex = 0; }
    }
  }

  // 約束角色不超出畫面邊界（可選）
  bottomX = constrain(bottomX, 0, width);

  // --- 更新下方動畫幀 ---
  const curAnim = anims[currentAnimKey];
  if (curAnim && curAnim.img) {
    if (millis() - bottomLastFrameTime > BOTTOM_FRAME_DURATION) {
      bottomFrameIndex = (bottomFrameIndex + 1) % curAnim.frames;
      bottomLastFrameTime = millis();
    }

    // 如果正在攻擊且已播放到最後一幀，結束攻擊並回復先前狀態
    if (isAttack && bottomFrameIndex === curAnim.frames - 1) {
      // 結束攻擊狀態
      isAttack = false;
      currentAnimKey = prevAnimKey || 'idle';
      bottomFrameIndex = 0;
      bottomLastFrameTime = millis();
    }

    // 繪製下方動畫（使用 bottomX, bottomY 位置）
    const sx2 = bottomFrameIndex * curAnim.srcW;
    const sy2 = 0;
    
    noTint();
    // 保存變換矩陣
    push();
    translate(bottomX, bottomY);
    // 根據 direction 翻轉水平方向
    scale(direction, 1);
    image(curAnim.img, 0, 0, curAnim.dispW, curAnim.dispH, sx2, sy2, curAnim.srcW, curAnim.srcH);
    pop();
  }

  // 繪製問題1精靈（固定位置，不隨角色移動，但跟隨視角翻轉） ---
  // 碰撞檢測
  if (!isProblem1Answered && millis() - lastCollisionCheckP1 > COLLISION_CHECK_INTERVAL) {
    lastCollisionCheckP1 = millis();
    const distanceToP1 = Math.abs(bottomX - PROBLEM1_X); // 問題1的固定X位置
    if (distanceToP1 < COLLISION_DISTANCE_P1) {
      // 觸發問題
      if (!questionActive) {
        questionActive = true;
        questionStartTime = millis();
        currentQuestion = random(QUESTIONS);
        userInput = "";
        // 聚焦隱藏輸入欄以接收中文輸入
        const hiddenInput = document.getElementById('hiddenInput');
        if (hiddenInput) {
          hiddenInput.value = "";
          hiddenInput.focus();
        }
      }
    }
  }

  // 碰撞檢測（問題2：右側精靈）
  if (!isProblem2Answered && millis() - lastCollisionCheckP2 > COLLISION_CHECK_INTERVAL) {
    lastCollisionCheckP2 = millis();
    const p2X = width - PROBLEM2_X_OFFSET; // 問題2 固定 X（向右微調）
    const distanceToP2 = Math.abs(bottomX - p2X);
    if (distanceToP2 < COLLISION_DISTANCE_P2) {
      if (!questionActive) {
        questionActive = true;
        questionStartTime = millis();
        // 問題2題庫（數字題）
        const p2Questions = [
          { text: "50*50=", answer: "2500", hint: "先算5*5等於多少再看看有多少0再加上去" },
          { text: "1600+1600=", answer: "3200", hint: "換角度去思考1600*2等於多少呢(可以先看看16*2=? )" },
          { text: "20*20-100=", answer: "300", hint: "先乘除後加減" }
        ];
        const idx = Math.floor(random(0, p2Questions.length));
        currentQuestion = p2Questions[idx];
        currentQuestion.source = 'problem2';
        currentQuestion.hintDisplay = false;
        userInput = "";
        const hiddenInput = document.getElementById('hiddenInput');
        if (hiddenInput) { hiddenInput.value = ""; hiddenInput.focus(); }
      }
    }
  }

  // 繪製問題1精靈
  if (!isProblem1Answered && problem1Img) {
    const fixedX = PROBLEM1_X; // 固定在視窗 X
    const fixedY = bottomY; // 與下方角色同一行

    push();
    translate(fixedX, fixedY);
    // 讓精靈面對角色 (若角色在左邊，精靈面向左)
    if (bottomX < fixedX) {
      scale(-1, 1);
    }
    image(problem1Img, 0, 0, PROBLEM1_W, PROBLEM1_H);
    pop();
  }

  // 繪製問題2精靈（右側，不動檔其實含多幀，這裡做簡單動畫）
  if (!isProblem2Answered && problem2Img) {
    const fixedX = width - PROBLEM2_X_OFFSET; // 靠右，微調偏移量
    const fixedY = bottomY;

    // 更新幀
    if (millis() - problem2LastFrameTime > PROBLEM2_FRAME_DURATION) {
      problem2FrameIndex = (problem2FrameIndex + 1) % 3;
      problem2LastFrameTime = millis();
    }

    const srcW2 = problem2Img.width / 3;
    const srcH2 = problem2Img.height;
    const sx2 = problem2FrameIndex * srcW2;

    push();
    translate(fixedX, fixedY);
    // 讓精靈面對角色 (若角色在左邊，精靈面向左)
    if (bottomX < fixedX) {
      scale(-1, 1);
    }
    image(problem2Img, 0, 0, PROBLEM2_W, PROBLEM2_H, sx2, 0, srcW2, srcH2);
    pop();
  }

  // 繪製問題2死亡動畫（答對後）
  if (isProblem2Answered && problem2DeathImg) {
    // 更新死亡動畫幀
    if (millis() - problem2DeathLastFrameTime > PROBLEM2_DEATH_FRAME_DURATION) {
      if (!problem2DeathFinished) {
        if (problem2DeathFrameIndex < 7) {
          problem2DeathFrameIndex = problem2DeathFrameIndex + 1;
          problem2DeathLastFrameTime = millis();
        } else {
          // 已到最後一幀，標記為完成並停止自動更新
          problem2DeathFinished = true;
        }
      }
    }

    const fixedX = width - PROBLEM2_X_OFFSET;
    const fixedY = bottomY;
    const srcW = problem2DeathImg.width / 8;
    const srcH = problem2DeathImg.height;
    const sx = problem2DeathFrameIndex * srcW;
    
    // 計算顯示尺寸，保持與不動精靈相同的高度比例
    const displayH = PROBLEM2_H; // 使用不動精靈的高度
    const displayW = displayH * (srcW / srcH); // 保持寬高比

    push();
    translate(fixedX, fixedY);
    // 死亡動畫播放期間面對角色，播放完畢後保持最後方向
    if (!problem2DeathFinished) {
      // 如果角色在左邊，面向左(-1)，否則面向右(1)
      problem2DeathDirection = (bottomX < fixedX) ? -1 : 1;
    }
    scale(problem2DeathDirection, 1);
    image(problem2DeathImg, 0, 0, displayW, displayH, sx, 0, srcW, srcH);
    pop();
  }

  // 繪製問題1答對精靈（答對後）
  if (isProblem1Answered && problem1CorrectImg) {
    // 更新答對精靈動畫幀
    if (millis() - problem1CorrectLastFrameTime > PROBLEM1_CORRECT_FRAME_DURATION) {
      if (!problem1DeathFinished) {
        if (problem1CorrectFrameIndex < 2) {
          problem1CorrectFrameIndex = problem1CorrectFrameIndex + 1;
          problem1CorrectLastFrameTime = millis();
        } else {
          // 已到最後一幀，標記為完成並停止自動更新
          problem1DeathFinished = true;
        }
      }
    }

    const fixedX = 100;
    const fixedY = bottomY;
    const srcW = problem1CorrectImg.width / 3;
    const srcH = problem1CorrectImg.height;
    const sx = problem1CorrectFrameIndex * srcW;
    
    // 計算顯示尺寸，保持寬高比
    const displayH = PROBLEM1_CORRECT_H;
    const displayW = displayH * (srcW / srcH);

    push();
    translate(fixedX, fixedY);
    // 死亡動畫播放期間面對角色，播放完畢後保持最後方向
    if (!problem1DeathFinished) {
      // 如果角色在左邊，面向左(-1)，否則面向右(1)
      problem1DeathDirection = (bottomX < fixedX) ? -1 : 1;
    }
    scale(problem1DeathDirection, 1);
    image(problem1CorrectImg, 0, 0, displayW, displayH, sx, 0, srcW, srcH);
    pop();
  }

  // 繪製問題UI
  if (questionActive && currentQuestion) {
    drawQuestionUI();
    // 確保隱藏輸入欄在問題啟動時持續獲得焦點
    const hiddenInput = document.getElementById('hiddenInput');
    if (hiddenInput && document.activeElement !== hiddenInput) {
      hiddenInput.focus();
    }
  }
  
}

// 繪製問題UI和輸入框
function drawQuestionUI() {
  const inputBoxH = 40; // 輸入框高度 (還原)
  const inputBoxW = 400; // 輸入框寬度 (還原)
  
  // 決定題目框的位置（在該問題的圖片精靈位置）
  let questionBoxX, questionBoxY;
  if (currentQuestion.source === 'problem2') {
    // 問題2在右側
    questionBoxX = width - PROBLEM2_X_OFFSET;
    questionBoxY = bottomY;
  } else {
    // 問題1在左側
    questionBoxX = PROBLEM1_X;
    questionBoxY = bottomY;
  }
  
  // 限制問題框 X 座標，避免超出視窗
  questionBoxX = constrain(questionBoxX, 150, width - 150);

  // 回答框 (改回固定在畫面中央)
  const answerBoxX = width / 2;
  const answerBoxY = bottomY - 100;
  
  // 提示框在最上方中央
  const hintBoxX = width / 2;
  const hintBoxY = height / 2 - 150;

  // 題目框（在該問題圖片精靈位置）
  if (!currentQuestion.hintDisplay) {
    fill(0, 0, 0, 200);
    stroke(255);
    strokeWeight(2);
    rect(questionBoxX - 150, questionBoxY - 110, 300, 60, 8); // 題目框加大

    fill(255);
    textSize(20); // 題目字體加大
    textAlign(CENTER, CENTER);
    text(currentQuestion.text, questionBoxX, questionBoxY - 80);
  }

  // 提示框（在上方圖片精靈）
  if (currentQuestion.hintDisplay) {
    fill(0, 0, 0, 200);
    stroke(255);
    strokeWeight(2);
    rect(hintBoxX - 210, hintBoxY - 50, 420, 50, 8);

    fill(255, 150, 0);
    textSize(16);
    textAlign(CENTER, CENTER);
    text("提示: " + currentQuestion.hint, hintBoxX, hintBoxY - 25);
  }

  // 回答框（在移動角色精靈上方）
  fill(255);
  stroke(100);
  strokeWeight(2);
  rect(answerBoxX - inputBoxW / 2, answerBoxY - 30, inputBoxW, inputBoxH, 4);

  // 輸入文字
  fill(0);
  textSize(16); // 輸入字體還原
  textAlign(LEFT, CENTER);
  text(userInput, answerBoxX - inputBoxW / 2 + 15, answerBoxY - 10);

  // 輸入游標閃爍
  if (Math.floor(millis() / 500) % 2 === 0) {
    stroke(0);
    strokeWeight(2);
    line(answerBoxX - inputBoxW / 2 + 15 + textWidth(userInput), answerBoxY - 30, answerBoxX - inputBoxW / 2 + 15 + textWidth(userInput), answerBoxY + 10);
  }

  // 提示文字（在回答框下方）
  fill(200, 100, 100);
  textSize(12);
  textAlign(CENTER, TOP);
  text(`按 ENTER 提交, BACKSPACE 刪除`, answerBoxX, answerBoxY + 20);
}

// 當使用者按下左方向鍵，觸發攻擊動畫（完整播放後自動回復）
function keyPressed() {
  // 如果問題正在進行中，只處理ENTER和BACKSPACE，其他交給隱藏輸入欄
  if (questionActive && currentQuestion) {
    if (keyCode === ENTER) {
      // 檢查答案
      checkAnswer();
      return false;
    } else if (keyCode === BACKSPACE) {
      // 刪除上一個字符
      userInput = userInput.slice(0, -1);
      const hiddenInput = document.getElementById('hiddenInput');
      if (hiddenInput) {
        hiddenInput.value = userInput;
      }
      return false;
    }
    // 不攔截其他鍵，讓隱藏輸入欄接收字符輸入
    return;
  }

  // 原本的攻擊邏輯
  if (keyCode === LEFT_ARROW) {
    // 只有在非攻擊時才觸發一次攻擊
    if (!isAttack) {
      prevAnimKey = currentAnimKey;
      currentAnimKey = 'attack';
      isAttack = true;
      bottomFrameIndex = 0;
      bottomLastFrameTime = millis();
    }
  }
}

// 檢查答案
function checkAnswer() {
  const inputTrimmed = userInput.trim();
  
  if (currentQuestion && currentQuestion.source === 'problem2') {
    // 處理問題2的判斷（數字題）
    if (inputTrimmed === currentQuestion.answer) {
      // 問題2答對
      isProblem2Answered = true;
      questionActive = false;
      userInput = "";
      problem2DeathLastFrameTime = millis();
      problem2DeathFrameIndex = 0;
      problem2DeathFinished = false; // 開始播放死亡動畫（尚未完成）
    } else {
      // 答錯，顯示提示
      showHint();
      userInput = ""; // 清空輸入，讓玩家重新開始
    }
  } else {
    // 預設回退到問題1的行為（舊題庫）
    if (currentQuestion && inputTrimmed === currentQuestion.answer) {
      // 答對了
      isProblem1Answered = true;
      questionActive = false;
      userInput = "";
      problem1CorrectLastFrameTime = millis();
      problem1CorrectFrameIndex = 0;
      problem1DeathFinished = false; // 開始播放死亡動畫（尚未完成）
    } else {
      // 答錯，顯示提示
      showHint();
      userInput = ""; // 清空輸入，讓玩家重新開始
    }
  }
  
  // 清空隱藏輸入欄並失去焦點，讓 p5.js 恢復鍵盤控制
  const hiddenInput = document.getElementById('hiddenInput');
  if (hiddenInput) {
    hiddenInput.value = "";
    hiddenInput.blur(); // 失去焦點
  }
}

// 顯示提示
function showHint() {
  // 提示文字暫時替換為提示內容
  currentQuestion.hintDisplay = true;
  currentQuestion.hintStartTime = millis();
  // 3秒後回復原問題
  setTimeout(() => {
    if (currentQuestion) {
      currentQuestion.hintDisplay = false;
    }
  }, 3000);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}